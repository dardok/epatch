From 856e10a08a8a229402d755d289ad3ff00d2035a8 Mon Sep 17 00:00:00 2001
From: =?UTF-8?q?Zbigniew=20J=C4=99drzejewski-Szmek?= <zbyszek@in.waw.pl>
Date: Sun, 25 Jun 2017 17:09:05 -0400
Subject: [PATCH] basic/random-util: do not fall back to /dev/urandom if
 getrandom() returns short
MIME-Version: 1.0
Content-Type: text/plain; charset=UTF-8
Content-Transfer-Encoding: 8bit

During early boot, we'd call getrandom(), and immediately fall back to
reading from /dev/urandom unless we got the full requested number of bytes.
Those two sources are the same, so the most likely result is /dev/urandom
producing some pseudorandom numbers for us, complaining widely on the way.

Let's change our behaviour to be more conservative:
- if the numbers are only used to initialize a hash table, a short read
  is OK, we don't really care if we get the first part of the seed and then
  some zeros. So just return "success" in that case.
- if getrandom() returns -EAGAIN, fall back to rand() instead of querying
  /dev/urandom again.
  The idea with those two changes is to avoid generating a warning about
  reading from an /dev/urandom when the kernel doesn't have enough entropy.
- only in the cases where we really need to make the best effort possible
  (sd_id128_randomize and firstboot password hashing), fall back to
  /dev/urandom.

sd_id128_randomize is a special case — for our internal uses we'd be fine to
fall back to rand(), but when provided as a function in sd_id128.so, we don't
know whether srand() was called properly, and how rand() is used otherwise, so
we cannot fall back to rand(). In that case using /dev/urandom is the only
reasonable fallback.

When falling back to /dev/urandom, don't lose the short read we already got,
and just read the remaining bytes.

When calling getrandom(), drop the checks whether the argument fits in an int —
getrandom() should do that for us already, and we call it with small arguments
only anyway.

Note that this does not really change the (relatively high) number of random
bytes we request from the kernel. On my laptop, during boot, PID 1 and all
other processes using this code through libsystemd request:
  74780 bytes with high_quality_required == false
    464 bytes with high_quality_required == true
and it does not eliminate reads from /dev/urandom completely. If the kernel was
short on entropy and getrandom() would fail, we would fall back to /dev/urandom
for those 464 bytes.

If getrandom() syscall is not available, we fall back to /dev/urandom same
as before.

Fixes #4167 (possibly partially, let's see).
---
 man/sd_id128_randomize.xml         |  2 +-
 src/basic/random-util.c            | 72 ++++++++++++++++++++------------------
 src/basic/random-util.h            |  3 +-
 src/firstboot/firstboot.c          |  2 +-
 src/libsystemd/sd-id128/sd-id128.c |  2 +-
 5 files changed, 42 insertions(+), 39 deletions(-)

diff --git a/man/sd_id128_randomize.xml b/man/sd_id128_randomize.xml
index 852a9fd7eb..26b19c666a 100644
--- a/man/sd_id128_randomize.xml
+++ b/man/sd_id128_randomize.xml
@@ -67,7 +67,7 @@
     <parameter>ret</parameter>. Every invocation returns a new
     randomly generated ID. This uses the
     <filename>/dev/urandom</filename> kernel random number
-    generator.</para>
+    generator, i.e. not a crytographically secure random number source.</para>
 
     <para>Note that <function>sd_id128_randomize()</function> always
     returns a UUID v4-compatible ID.</para>
diff --git a/src/basic/random-util.c b/src/basic/random-util.c
index b216be579d..e8cc66ccf0 100644
--- a/src/basic/random-util.c
+++ b/src/basic/random-util.c
@@ -42,53 +42,54 @@
 #include "random-util.h"
 #include "time-util.h"
 
-int dev_urandom(void *p, size_t n) {
+int acquire_random_bytes(void *p, size_t n, bool high_quality_required) {
         static int have_syscall = -1;
 
         _cleanup_close_ int fd = -1;
         int r;
+        unsigned already_done = 0;
 
-        /* Gathers some randomness from the kernel. This call will
-         * never block, and will always return some data from the
-         * kernel, regardless if the random pool is fully initialized
-         * or not. It thus makes no guarantee for the quality of the
-         * returned entropy, but is good enough for our usual usecases
-         * of seeding the hash functions for hashtable */
+        /* Gathers some randomness from the kernel. This call will never block. If
+         * high_quality_required, it will always return some data from the kernel,
+         * regardless of whether the random pool is fully initialized or not.
+         * Otherwise, it will return success if at least some random bytes were
+         * successfully acquired, and an error if the kernel has no entropy whatsover
+         * for us. */
 
-        /* Use the getrandom() syscall unless we know we don't have
-         * it, or when the requested size is too large for it. */
-        if (have_syscall != 0 || (size_t) (int) n != n) {
+        /* Use the getrandom() syscall unless we know we don't have it. */
+        if (have_syscall != 0) {
                 r = getrandom(p, n, GRND_NONBLOCK);
-                if (r == (int) n) {
+                if (r > 0) {
                         have_syscall = true;
-                        return 0;
-                }
-
-                if (r < 0) {
-                        if (errno == ENOSYS)
-                                /* we lack the syscall, continue with
-                                 * reading from /dev/urandom */
-                                have_syscall = false;
-                        else if (errno == EAGAIN)
-                                /* not enough entropy for now. Let's
-                                 * remember to use the syscall the
-                                 * next time, again, but also read
-                                 * from /dev/urandom for now, which
-                                 * doesn't care about the current
-                                 * amount of entropy.  */
-                                have_syscall = true;
-                        else
-                                return -errno;
+                        if (r == n || !high_quality_required)
+                                return 0;
+
+                        already_done = r;
+                } else if (errno == ENOSYS)
+                          /* We lack the syscall, continue with reading from /dev/urandom. */
+                          have_syscall = false;
+                else if (errno == EAGAIN) {
+                        /* The kernel has no entropy whatsoever. Let's remember to
+                         * use the syscall the next time again though.
+                         *
+                         * If high_quality_required is false, return an error so that
+                         * random_bytes() can produce some pseudorandom
+                         * bytes. Otherwise, fall back to /dev/urandom, which we know
+                         * is empty, but the kernel will produce some bytes for us on
+                         * a best-effort basis. */
+                        have_syscall = true;
+
+                        if (!high_quality_required)
+                                return -ENODATA;
                 } else
-                        /* too short read? */
-                        return -ENODATA;
+                        return -errno;
         }
 
         fd = open("/dev/urandom", O_RDONLY|O_CLOEXEC|O_NOCTTY);
         if (fd < 0)
                 return errno == ENOENT ? -ENOSYS : -errno;
 
-        return loop_read_exact(fd, p, n, true);
+        return loop_read_exact(fd, (uint8_t*) p + already_done, n - already_done, true);
 }
 
 void initialize_srand(void) {
@@ -102,8 +103,9 @@ void initialize_srand(void) {
                 return;
 
 #ifdef HAVE_SYS_AUXV_H
-        /* The kernel provides us with 16 bytes of entropy in auxv, so let's try to make use of that to seed the
-         * pseudo-random generator. It's better than nothing... */
+        /* The kernel provides us with 16 bytes of entropy in auxv, so let's
+         * try to make use of that to seed the pseudo-random generator. It's
+         * better than nothing... */
 
         auxv = (void*) getauxval(AT_RANDOM);
         if (auxv) {
@@ -125,7 +127,7 @@ void random_bytes(void *p, size_t n) {
         uint8_t *q;
         int r;
 
-        r = dev_urandom(p, n);
+        r = acquire_random_bytes(p, n, false);
         if (r >= 0)
                 return;
 
diff --git a/src/basic/random-util.h b/src/basic/random-util.h
index 3cee4c5014..001d4c18fe 100644
--- a/src/basic/random-util.h
+++ b/src/basic/random-util.h
@@ -19,10 +19,11 @@
   along with systemd; If not, see <http://www.gnu.org/licenses/>.
 ***/
 
+#include <stdbool.h>
 #include <stddef.h>
 #include <stdint.h>
 
-int dev_urandom(void *p, size_t n);
+int acquire_random_bytes(void *p, size_t n, bool high_quality_required);
 void random_bytes(void *p, size_t n);
 void initialize_srand(void);
 
diff --git a/src/firstboot/firstboot.c b/src/firstboot/firstboot.c
index bc16290c72..b3578d3e16 100644
--- a/src/firstboot/firstboot.c
+++ b/src/firstboot/firstboot.c
@@ -572,7 +572,7 @@ static int process_root_password(void) {
         if (!arg_root_password)
                 return 0;
 
-        r = dev_urandom(raw, 16);
+        r = acquire_random_bytes(raw, 16, true);
         if (r < 0)
                 return log_error_errno(r, "Failed to get salt: %m");
 
diff --git a/src/libsystemd/sd-id128/sd-id128.c b/src/libsystemd/sd-id128/sd-id128.c
index cc89f2de2e..b1f6c5305f 100644
--- a/src/libsystemd/sd-id128/sd-id128.c
+++ b/src/libsystemd/sd-id128/sd-id128.c
@@ -289,7 +289,7 @@ _public_ int sd_id128_randomize(sd_id128_t *ret) {
 
         assert_return(ret, -EINVAL);
 
-        r = dev_urandom(&t, sizeof(t));
+        r = acquire_random_bytes(&t, sizeof t, true);
         if (r < 0)
                 return r;
 
